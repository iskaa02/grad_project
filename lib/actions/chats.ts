"use server";

import { revalidatePath } from "next/cache";
import { db } from "../db";
import { chats, type Chat } from "../db/schema/chats"; // Import Chat type
import { messages, type MessageRole } from "../db/schema/messages"; // Import MessageRole type
import { auth } from "@clerk/nextjs/server";
import { eq, and, desc, sql } from "drizzle-orm";
import { redirect } from "next/navigation";
import { type Message as VercelAIMessage } from "ai"; // Import Vercel AI SDK Message type for input
import { nanoid } from "nanoid";

// Type definition for message input structure (subset of Vercel AI SDK Message)
// We only need role and content for saving, ID is generated by DB or comes from SDK
interface MessageInput {
  role: MessageRole;
  content: string;
  // Include other fields from VercelAIMessage if you need to save them
  // id?: string;
  // name?: string;
  // tool_call_id?: string;
  // tool_calls?: any;
}

/**
 * Get all chat sessions for the currently logged-in user.
 */
export const getUserChats = async (): Promise<Chat[]> => {
  const { userId } = await auth();
  console.log("User ID:", userId);
  if (!userId) {
    return [];
  }

  try {
    const userChats = await db
      .select()
      .from(chats)
      .where(eq(chats.userId, userId))
      .orderBy(desc(chats.updatedAt)); // Show most recent chats first

    return userChats;
  } catch (error) {
    console.error("Failed to get user chats:", error);
    throw new Error("Could not retrieve chat history."); // Throw a user-friendly error
  }
};

/**
 * Get messages for a specific chat session, verifying user ownership.
 * Returns messages in the format expected by Vercel AI SDK useChat hook.
 */
export const getMessagesForChat = async (
  chatId: string,
): Promise<VercelAIMessage[]> => {
  const { userId } = await auth();
  if (!userId) {
    throw new Error("You must be signed in to view messages.");
  }

  try {
    // First, verify the chat belongs to the user
    const chat = await db
      .select({ id: chats.id })
      .from(chats)
      .where(and(eq(chats.id, chatId), eq(chats.userId, userId)))
      .limit(1);

    if (!chat.length) {
      throw new Error(
        "Chat not found or you don't have permission to view it.",
      );
    }

    // Fetch messages for the validated chat
    const chatMessages = await db
      .select({
        id: messages.id,
        role: messages.role,
        content: messages.content,
        createdAt: messages.createdAt, // Keep createdAt if needed for sorting/display
        // Select other fields like name, tool_call_id if stored and needed by useChat
      })
      .from(messages)
      .where(eq(messages.chatId, chatId))
      .orderBy(messages.createdAt); // Ensure messages are in chronological order

    // Map to the format expected by Vercel AI SDK useChat hook { id, role, content, ... }
    return chatMessages.map((msg) => ({
      id: msg.id, // Use the DB message ID
      role: msg.role as "user" | "assistant" | "system" | "data", // Role is already typed correctly via schema
      content: msg.content,
      // Map other fields if necessary
    }));
  } catch (error) {
    console.error(`Failed to get messages for chat ${chatId}:`, error);
    if (error instanceof Error && error.message.includes("Chat not found")) {
      throw error; // Re-throw specific known errors
    }
    throw new Error("Could not retrieve messages for this chat.");
  }
};

/**
 * Create a new chat session, add the initial messages, and redirect to it.
 * Expects initial messages in the Vercel AI SDK format.
 */
export const createChatSession = async (
  chatId: string,
  initialMessages: VercelAIMessage[],
) => {
  const { userId } = await auth();
  if (!userId) {
    throw new Error("You must be signed in to create a chat.");
  }

  try {
    // 1. Create the new chat entry
    const firstUserMessage =
      initialMessages.find((m) => m.role === "user")?.content || "New Chat";
    const title =
      firstUserMessage.substring(0, 50) +
      (firstUserMessage.length > 50 ? "..." : ""); // Generate title

    await db.insert(chats).values({
      userId: userId,
      id: chatId,
      title: title,
    });

    // 2. Insert the initial messages (which should just be the first user message in this case)
    // Ensure your 'messages' schema has columns for id, chatId, role, and content
    const messagesToInsert = initialMessages.map((msg) => ({
      id: msg.id || nanoid(), // Use existing ID if available, otherwise generate
      chatId: chatId, // Link message to the new chat
      role: msg.role,
      content: msg.content,
      // Add other columns like createdAt, updatedAt if they exist in your schema
    }));

    if (messagesToInsert.length > 0) {
      await db.insert(messages).values(messagesToInsert);
    }
  } catch (error) {
    console.error(
      "Failed to create chat session or save initial message:",
      error,
    );
    // You might want to throw a more specific error or handle differently
    throw new Error(
      "Failed to start a new chat session and save initial message.",
    );
  }
};

/**
 * Add a new message to an existing chat session.
 */
export const addMessageToChat = async (
  chatId: string,
  message: VercelAIMessage, // Use Vercel AI SDK Message type
) => {
  const { userId } = await auth();
  if (!userId) {
    throw new Error("You must be signed in to add messages.");
  }

  // Basic validation of the message object
  if (!message || !message.role || typeof message.content !== "string") {
    throw new Error("Invalid message format.");
  }

  try {
    // Verify chat ownership before inserting (important for security)
    const chat = await db
      .select({ id: chats.id })
      .from(chats)
      .where(and(eq(chats.id, chatId), eq(chats.userId, userId)))
      .limit(1);

    if (!chat.length) {
      throw new Error("Chat not found or permission denied.");
    }

    // Insert the new message
    await db.insert(messages).values({
      chatId: chatId,
      role: message.role, // Role must match MessageRole type
      content: message.content,
      id: message.id ?? nanoid(),
      // Map other fields if needed (name, tool_call_id, etc.)
    });

    // Update the chat's updatedAt timestamp using the database function for consistency
    await db
      .update(chats)
      .set({ updatedAt: sql`now()` }) // Use SQL now()
      .where(eq(chats.id, chatId));

    // Revalidate paths to update UI
    revalidatePath(`/chat/${chatId}`); // Revalidate the specific chat page
    revalidatePath("/chat"); // Revalidate the sidebar list
  } catch (error) {
    console.error(`Failed to add message to chat ${chatId}:`, error);
    if (error instanceof Error && error.message.includes("permission denied")) {
      throw error; // Re-throw specific known errors
    }
    throw new Error("Failed to save message.");
  }
};

/**
 * Delete a chat session and its associated messages.
 */
export const deleteChatSession = async (chatId: string) => {
  const { userId } = await auth();
  if (!userId) {
    throw new Error("You must be signed in to delete chats.");
  }

  try {
    // Use a transaction to ensure atomicity if needed, though cascade delete handles messages.
    // Verify ownership and delete in one step.
    const result = await db
      .delete(chats)
      .where(and(eq(chats.id, chatId), eq(chats.userId, userId)))
      .returning({ id: chats.id }); // Check if a row was actually deleted

    if (result.length === 0) {
      throw new Error("Chat not found or permission denied.");
    }
  } catch (error) {
    console.error(`Failed to delete chat session ${chatId}:`, error);
    if (error instanceof Error && error.message.includes("permission denied")) {
      throw error; // Re-throw specific known errors
    }
    throw new Error("Failed to delete chat.");
  }
};

/**
 * Rename a chat session.
 */
export const renameChatSession = async (chatId: string, newTitle: string) => {
  const { userId } = await auth();
  if (!userId) {
    throw new Error("You must be signed in to rename chats.");
  }
  if (!newTitle || newTitle.trim().length === 0) {
    throw new Error("Title cannot be empty.");
  }

  try {
    const result = await db
      .update(chats)
      .set({ title: newTitle.trim() })
      .where(and(eq(chats.id, chatId), eq(chats.userId, userId)))
      .returning({ id: chats.id });

    if (result.length === 0) {
      throw new Error("Chat not found or permission denied.");
    }

    revalidatePath("/chat"); // Update sidebar
    revalidatePath(`/chat/${chatId}`); // Update chat page if title is shown there
  } catch (error) {
    console.error(`Failed to rename chat session ${chatId}:`, error);
    throw new Error("Failed to rename chat.");
  }
};
